---
phase: 03-dashboard-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/monocli/ui/__init__.py
  - src/monocli/ui/sections.py
  - tests/ui/__init__.py
  - tests/ui/test_sections.py
autonomous: true

must_haves:
  truths:
    - "MergeRequestSection widget exists and renders a DataTable"
    - "WorkItemSection widget exists and renders a DataTable"
    - "Each section displays correct columns per CONTEXT.md specification"
    - "Loading spinners appear alongside section titles during data fetch"
    - "Empty states show friendly messages when no data"
    - "Error states display error messages in place of content"
  artifacts:
    - path: "src/monocli/ui/__init__.py"
      provides: "UI package exports"
      min_lines: 5
    - path: "src/monocli/ui/sections.py"
      provides: "Section widget implementations"
      exports: ["MergeRequestSection", "WorkItemSection"]
      min_lines: 150
    - path: "tests/ui/test_sections.py"
      provides: "Widget integration tests"
      min_lines: 80
  key_links:
    - from: "src/monocli/ui/sections.py"
      to: "src/monocli/models.py"
      via: "imports MergeRequest, JiraWorkItem"
      pattern: "from monocli.models import"
---

<objective>
Create reusable section widgets for displaying merge requests and work items using Textual's DataTable widget.

Purpose: Provide the building blocks for the dashboard's two-section layout. These widgets handle their own data presentation, loading states, and empty/error states independently.
Output: MergeRequestSection and WorkItemSection classes ready for composition into the main screen.
</objective>

<execution_context>
@/Users/pg/.config/opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-dashboard-ui/03-CONTEXT.md
@src/monocli/models.py
@src/monocli/adapters/gitlab.py
@src/monocli/adapters/jira.py

## User Decisions (LOCKED â€” must implement exactly)

From 03-CONTEXT.md:

**Section layout:**
- 50/50 split between PRs/MRs (top) and Work Items (bottom) sections
- Each section has its own scrollbar when content overflows

**Item presentation format:**
- **PRs/MRs section columns:** Key/Number, Title, Status, Author, Branch, Created Date
- **Work Items section columns:** Key, Title, Status, Priority, Assignee, Created Date
- **Long titles:** Truncate with ellipsis (...)
- Use DataTable widget for both sections

**Loading & empty states:**
- Loading spinners appear alongside/beside section titles (not replacing content)
- Empty state: Show friendly message like "No merge requests found" or "No assigned work items"
- Error handling: Display error message in place of content (e.g., "Failed to load GitLab MRs")

**Claude's discretion:**
- Visual styling of section containers
- Exact spinner style (use simple/minimalist per user request)
- Empty/error message wording
- Color scheme and theming
</context>

<tasks>

<task type="auto">
  <name>Create UI package structure</name>
  <files>src/monocli/ui/__init__.py, tests/ui/__init__.py</files>
  <action>
    Create the UI package structure:
    1. Create src/monocli/ui/__init__.py with exports for sections module
    2. Create tests/ui/__init__.py for test package
    3. Ensure proper imports and type hints
  </action>
  <verify>ls -la src/monocli/ui/ tests/ui/</verify>
  <done>UI package directories and __init__.py files exist</done>
</task>

<task type="auto">
  <name>Create MergeRequestSection widget</name>
  <files>src/monocli/ui/sections.py</files>
  <action>
    Create the MergeRequestSection widget class in src/monocli/ui/sections.py:

    1. Create a class that extends textual.widgets.Static or Container
    2. Accept merge_requests: list[MergeRequest] as reactive data
    3. Use DataTable widget internally with columns:
       - Key (from display_key())
       - Title (truncated with ellipsis if >40 chars)
       - Status (from display_status())
       - Author (author.name or author.login)
       - Branch (source_branch)
       - Created (formatted date)
    4. Add loading state: show Loading indicator alongside title
    5. Add empty state: show "No merge requests found" message
    6. Add error state: show error message in DataTable area
    7. Implement method to set loading state
    8. Implement method to set error state with message
    9. Implement method to update data
    10. Store the selected row's URL for browser opening (later phase)

    Design choices (Claude's discretion):
    - Use border to visually distinguish section
    - Title formatting: "Merge Requests" with count when loaded
    - Spinner: use textual.widgets.LoadingIndicator
    - Style with CSS-like classes for active/inactive states
  </action>
  <verify>cd /Users/pg/Coding/_bucket/monocli && python -c "from monocli.ui.sections import MergeRequestSection; print('Import OK')"</verify>
  <done>MergeRequestSection class exists with DataTable, handles loading/empty/error states, uses display_key() and display_status() from models</done>
</task>

<task type="auto">
  <name>Create WorkItemSection widget</name>
  <files>src/monocli/ui/sections.py</files>
  <action>
    Create the WorkItemSection widget class in src/monocli/ui/sections.py:

    1. Create a class that extends textual.widgets.Static or Container
    2. Accept work_items: list[JiraWorkItem] as reactive data
    3. Use DataTable widget internally with columns:
       - Key (from display_key())
       - Title (truncated with ellipsis if >40 chars)
       - Status (from display_status())
       - Priority (from priority property)
       - Assignee (from assignee property or "Unassigned")
       - Created (formatted date if available)
    4. Add loading state: show Loading indicator alongside title
    5. Add empty state: show "No assigned work items" message
    6. Add error state: show error message in DataTable area
    7. Implement method to set loading state
    8. Implement method to set error state with message
    9. Implement method to update data
    10. Store the selected row's URL for browser opening (later phase)

    Design choices (Claude's discretion):
    - Consistent with MergeRequestSection styling
    - Title formatting: "Work Items" with count when loaded
    - Use same spinner style as MergeRequestSection
  </action>
  <verify>cd /Users/pg/Coding/_bucket/monocli && python -c "from monocli.ui.sections import WorkItemSection; print('Import OK')"</verify>
  <done>WorkItemSection class exists with DataTable, handles loading/empty/error states, uses display_key() and display_status() from models</done>
</task>

<task type="auto">
  <name>Create integration tests for section widgets</name>
  <files>tests/ui/test_sections.py</files>
  <action>
    Create integration tests for section widgets using Textual's Pilot API:

    1. Test MergeRequestSection renders DataTable with correct columns
    2. Test WorkItemSection renders DataTable with correct columns
    3. Test loading state shows spinner/indicator
    4. Test empty state shows appropriate message
    5. Test error state shows error message
    6. Test data updates refresh the table correctly
    7. Test row selection (DataTable row highlighting)

    Use textual.pilot.Pilot for testing widget behavior.
    Create mock data using the Pydantic models from src/monocli/models.py.
  </action>
  <verify>cd /Users/pg/Coding/_bucket/monocli && python -m pytest tests/ui/test_sections.py -v</verify>
  <done>All section widget tests pass, covering rendering, states, and data updates</done>
</task>

</tasks>

<verification>
1. Both section widgets can be imported from monocli.ui.sections
2. DataTable columns match CONTEXT.md specification
3. Loading, empty, and error states work correctly
4. Tests pass with pytest
5. Code follows existing project patterns (Ruff, MyPy)
</verification>

<success_criteria>
- MergeRequestSection and WorkItemSection classes exist and are importable
- Each widget displays correct columns per user specification
- Loading spinners appear alongside titles (not replacing content)
- Empty states show friendly messages
- Error states display error messages in content area
- Integration tests verify widget behavior with Pilot class
</success_criteria>

<output>
After completion, create `.planning/phases/03-dashboard-ui/03-01-SUMMARY.md`
</output>
