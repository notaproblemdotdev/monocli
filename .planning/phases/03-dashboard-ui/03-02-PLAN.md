---
phase: 03-dashboard-ui
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - src/monocli/ui/app.py
  - src/monocli/ui/main_screen.py
  - src/monocli/__main__.py
  - tests/ui/test_main_screen.py
autonomous: true

must_haves:
  truths:
    - "MainScreen exists with two sections in 50/50 vertical layout"
    - "App detects available CLIs and shows only relevant sections"
    - "Sections display loading spinners during initial data fetch"
    - "Data fetches asynchronously using Textual Workers"
    - "UI remains responsive during data fetching"
  artifacts:
    - path: "src/monocli/ui/app.py"
      provides: "Textual App class with CLI detection"
      exports: ["MonoApp"]
      min_lines: 80
    - path: "src/monocli/ui/main_screen.py"
      provides: "Main screen with two-section layout"
      exports: ["MainScreen"]
      min_lines: 100
    - path: "src/monocli/__main__.py"
      provides: "Entry point to run the app"
      min_lines: 10
    - path: "tests/ui/test_main_screen.py"
      provides: "Main screen integration tests"
      min_lines: 60
  key_links:
    - from: "src/monocli/ui/main_screen.py"
      to: "src/monocli/ui/sections.py"
      via: "imports MergeRequestSection, WorkItemSection"
      pattern: "from monocli.ui.sections import"
    - from: "src/monocli/ui/main_screen.py"
      to: "src/monocli/adapters/detection.py"
      via: "uses DetectionRegistry"
      pattern: "DetectionRegistry"
    - from: "src/monocli/ui/main_screen.py"
      to: "src/monocli/adapters/gitlab.py"
      via: "uses GitLabAdapter"
      pattern: "GitLabAdapter"
    - from: "src/monocli/ui/main_screen.py"
      to: "src/monocli/adapters/jira.py"
      via: "uses JiraAdapter"
      pattern: "JiraAdapter"
    - from: "src/monocli/ui/main_screen.py"
      to: "src/monocli/async_utils.py"
      via: "uses @work decorator"
      pattern: "@work"
---

<objective>
Create the main Textual application with two-section layout and async data fetching.

Purpose: Wire together the section widgets with real data fetching from GitLab and Jira adapters. The main screen composes the layout and manages data loading.
Output: Working MonoApp that displays MRs and Work Items in a two-section dashboard with async loading.
</objective>

<execution_context>
@/Users/pg/.config/opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-dashboard-ui/03-CONTEXT.md
@src/monocli/ui/sections.py
@src/monocli/adapters/detection.py
@src/monocli/adapters/gitlab.py
@src/monocli/adapters/jira.py
@src/monocli/async_utils.py

## Prior Phase Output

From 03-01 (Section Widgets):
- MergeRequestSection widget with DataTable, loading/empty/error states
- WorkItemSection widget with DataTable, loading/empty/error states
- Both in src/monocli/ui/sections.py

## User Decisions (LOCKED — must implement exactly)

From 03-CONTEXT.md:

**Section layout:**
- 50/50 split between PRs/MRs (top) and Work Items (bottom) sections
- Fixed height sections, not collapsible
- Each section has its own scrollbar when content overflows

**Loading & empty states:**
- Loading spinners appear alongside/beside section titles (not replacing content)
- Empty state: Show friendly message
- Error handling: Display error message in place of content

**Navigation (for context, implemented in 03-03):**
- Tab key switches active section (top ↔ bottom)
- Visual indicator shows which section is currently active
- Pressing 'o' opens selected item in browser

## Established Patterns (from STATE.md)

From Phase 1 and 2:
- Use @work(exclusive=True) to prevent race conditions
- Use DetectionRegistry for CLI availability checking
- GitLabAdapter.fetch_assigned_mrs() returns list[MergeRequest]
- JiraAdapter.fetch_assigned_items() returns list[JiraWorkItem]
- Both adapters have check_auth() method
</context>

<tasks>

<task type="auto">
  <name>Create MainScreen with two-section layout</name>
  <files>src/monocli/ui/main_screen.py</files>
  <action>
    Create MainScreen class in src/monocli/ui/main_screen.py:

    1. Extend textual.screen.Screen
    2. Implement compose() method with:
       - Vertical layout (50/50 split using CSS fractional units)
       - MergeRequestSection at top (id="mr-section")
       - WorkItemSection at bottom (id="work-section")
       - Both sections have fixed height (50% each)
       - Scrollable containers for overflow
    3. Add reactive attributes for tracking:
       - Which section is currently active (for visual indicator)
       - Loading states for each section
    4. CSS styling:
       - Active section gets visual highlight (border or background)
       - Inactive section is dimmed or has normal styling
       - Use Textual's CSS system (DEFAULT_CSS or CSS_PATH)
    5. Mount handler to trigger initial data loading

    Design choices (Claude's discretion):
    - Use border style change to indicate active section (e.g., blue border)
    - Section titles with subtle styling
    - Layout using textual.containers.Vertical with fixed heights
  </action>
  <verify>cd /Users/pg/Coding/_bucket/monocli && python -c "from monocli.ui.main_screen import MainScreen; print('Import OK')"</verify>
  <done>MainScreen class exists with 50/50 vertical layout, imports and uses section widgets</done>
</task>

<task type="auto">
  <name>Implement async data fetching with Workers</name>
  <files>src/monocli/ui/main_screen.py</files>
  <action>
    Add async data fetching to MainScreen:

    1. Create async method fetch_merge_requests() decorated with @work(exclusive=True)
       - Set MergeRequestSection to loading state
       - Use GitLabAdapter to fetch MRs
       - Update section with data on success
       - Set error state on failure

    2. Create async method fetch_work_items() decorated with @work(exclusive=True)
       - Set WorkItemSection to loading state
       - Use JiraAdapter to fetch work items
       - Update section with data on success
       - Set error state on failure

    3. Create detect_and_fetch() method:
       - Use DetectionRegistry to check which CLIs are available
       - Only show/fetch data for available CLIs
       - Start both fetch workers concurrently

    4. Handle worker completion:
       - Remove loading spinners when workers complete
       - Log errors but don't crash

    5. Import needed modules:
       - from monocli.adapters.gitlab import GitLabAdapter
       - from monocli.adapters.jira import JiraAdapter
       - from monocli.adapters.detection import DetectionRegistry
       - from textual.workers import work

    Pattern reference: Use @work(exclusive=True) as established in Phase 1
  </action>
  <verify>cd /Users/pg/Coding/_bucket/monocli && python -m py_compile src/monocli/ui/main_screen.py</verify>
  <done>MainScreen has async fetch methods with @work(exclusive=True), uses GitLabAdapter and JiraAdapter</done>
</task>

<task type="auto">
  <name>Create MonoApp entry point</name>
  <files>src/monocli/ui/app.py, src/monocli/__main__.py</files>
  <action>
    Create the main application entry point:

    1. Create src/monocli/ui/app.py with MonoApp class:
       - Extend textual.app.App
       - Set SCREENS = {"main": MainScreen}
       - Set CSS_PATH if using external CSS file
       - Set TITLE = "Mono CLI"
       - Implement on_mount() to push main screen

    2. Create src/monocli/__main__.py:
       - Import MonoApp from monocli.ui.app
       - Add if __name__ == "__main__": block
       - Call MonoApp().run()

    3. Ensure proper package imports:
       - Update src/monocli/ui/__init__.py to export MonoApp
       - Or import directly from monocli.ui.app

    4. Test the app can be imported without errors:
       - No circular imports
       - All dependencies resolve
  </action>
  <verify>cd /Users/pg/Coding/_bucket/monocli && python -c "from monocli.ui.app import MonoApp; print('Import OK')"</verify>
  <done>MonoApp exists, can be imported, __main__.py provides entry point</done>
</task>

<task type="auto">
  <name>Create integration tests for main screen</name>
  <files>tests/ui/test_main_screen.py</files>
  <action>
    Create integration tests for the main screen:

    1. Test MainScreen renders both sections
    2. Test 50/50 layout structure (CSS verification)
    3. Test sections show loading state on mount
    4. Test data updates refresh sections (mock adapters)
    5. Test CLI detection hides unavailable sections
    6. Test error handling displays error messages

    Use textual.pilot.Pilot for testing:
    - async with app.run_test() as pilot
    - Query widgets with pilot.app.query_one()
    - Assert on widget states

    Mock the adapters to avoid needing actual CLI authentication.
    Use unittest.mock to patch GitLabAdapter and JiraAdapter.
  </action>
  <verify>cd /Users/pg/Coding/_bucket/monocli && python -m pytest tests/ui/test_main_screen.py -v</verify>
  <done>All main screen tests pass, covering layout, loading, data updates, and error handling</done>
</task>

</tasks>

<verification>
1. MonoApp can be run: python -m monocli
2. MainScreen shows both sections in 50/50 split
3. Loading spinners appear during data fetch
4. Data displays in DataTables when loaded
5. Error states show when fetch fails
6. Sections are hidden when CLI unavailable
7. UI remains responsive (no blocking)
8. Tests pass with pytest
</verification>

<success_criteria>
- MainScreen renders with two sections in 50/50 vertical layout
- App detects CLIs via DetectionRegistry and shows relevant sections only
- Data fetches asynchronously using @work(exclusive=True)
- Loading spinners show during fetch, removed on completion
- Error messages display when fetch fails
- App entry point works: python -m monocli
- Integration tests verify layout and async behavior
</success_criteria>

<output>
After completion, create `.planning/phases/03-dashboard-ui/03-02-SUMMARY.md`
</output>
