---
phase: 03-dashboard-ui
plan: 03
type: execute
wave: 3
depends_on:
  - 03-01
  - 03-02
files_modified:
  - src/monocli/ui/main_screen.py
  - src/monocli/ui/app.py
  - tests/ui/test_navigation.py
autonomous: true

must_haves:
  truths:
    - "User can press Tab to switch between sections"
    - "Active section has visual indicator (border highlight or styling)"
    - "User can navigate items with j/k or arrow keys within active section"
    - "User can press 'o' to open selected item in default browser"
    - "Selection is section-scoped (each section tracks its own selection)"
  artifacts:
    - path: "src/monocli/ui/main_screen.py"
      provides: "Navigation handling in MainScreen"
      exports: ["on_key", "action_switch_section", "action_open_browser"]
      min_lines: 150
    - path: "src/monocli/ui/sections.py"
      provides: "Section widget navigation support"
      exports: ["get_selected_url", "focus_table", "select_next", "select_previous"]
      min_lines: 200
    - path: "tests/ui/test_navigation.py"
      provides: "Navigation integration tests"
      min_lines: 100
  key_links:
    - from: "src/monocli/ui/main_screen.py"
      to: "src/monocli/ui/sections.py"
      via: "calls focus_table(), get_selected_url()"
      pattern: "section\.(focus_table|get_selected_url)"
    - from: "src/monocli/ui/main_screen.py"
      to: "webbrowser module"
      via: "opens browser with webbrowser.open()"
      pattern: "webbrowser\.open"
---

<objective>
Implement keyboard navigation and browser integration for the dashboard.

Purpose: Enable users to navigate between sections, browse items with keyboard, and open items in their default browser.
Output: Fully navigable dashboard with Tab switching, j/k navigation, and 'o' key browser integration.
</objective>

<execution_context>
@/Users/pg/.config/opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-dashboard-ui/03-CONTEXT.md
@src/monocli/ui/main_screen.py
@src/monocli/ui/sections.py
@src/monocli/ui/app.py

## Prior Phase Output

From 03-01 (Section Widgets):
- MergeRequestSection with DataTable, loading/empty/error states
- WorkItemSection with DataTable, loading/empty/error states

From 03-02 (Main Screen):
- MainScreen with 50/50 vertical layout
- Async data fetching with @work(exclusive=True)
- Detection-based section visibility

## User Decisions (LOCKED — must implement exactly)

From 03-CONTEXT.md:

**Navigation behavior:**
- Tab key switches active section (top ↔ bottom)
- j/k or arrow keys navigate items within the active section only
- Visual indicator shows which section is currently active (e.g., border highlight, title styling)
- Selection is section-scoped, not global

**Browser integration:**
- Pressing 'o' immediately opens the selected item in default browser (no confirmation)
- No visual feedback notification (browser opening is sufficient feedback)
- Handle browser open failures gracefully (log error, show brief message)

**Claude's discretion:**
- Exact visual styling of active section indicator
- Error message display format
</context>

<tasks>

<task type="auto">
  <name>Add section navigation methods to section widgets</name>
  <files>src/monocli/ui/sections.py</files>
  <action>
    Add navigation support methods to both section widgets:

    1. Add focus_table() method:
       - Focus the internal DataTable widget
       - Enable keyboard navigation within the table

    2. Add get_selected_url() -> str | None method:
       - Return the URL of the currently selected row
       - For MergeRequestSection: return str(mr.web_url)
       - For WorkItemSection: return item.url (from property)
       - Return None if no selection

    3. Add select_next() and select_previous() methods:
       - Move selection up/down in DataTable
       - These are wrappers around DataTable's navigation

    4. Store URL mapping:
       - Maintain a mapping from row_key to URL
       - Update mapping when data changes
       - Use this in get_selected_url()

    5. Ensure DataTable has:
       - cursor_type="row" for row selection
       - show_cursor=True
       - Focusable enabled

    Textual DataTable reference:
    - Use move_cursor() for programmatic navigation
    - Use get_row_at() or cursor_row for current position
    - Row keys link data to table rows
  </action>
  <verify>cd /Users/pg/Coding/_bucket/monocli && python -c "from monocli.ui.sections import MergeRequestSection, WorkItemSection; s = MergeRequestSection(); print('focus_table:', hasattr(s, 'focus_table')); print('get_selected_url:', hasattr(s, 'get_selected_url'))"</verify>
  <done>Both section widgets have focus_table(), get_selected_url(), select_next(), select_previous() methods</done>
</task>

<task type="auto">
  <name>Implement Tab key section switching</name>
  <files>src/monocli/ui/main_screen.py</files>
  <action>
    Add Tab key handling for section switching:

    1. Add reactive attribute: active_section_id (str, default="mr-section")

    2. Implement on_key() handler:
       - Catch "tab" key press
       - Toggle active_section_id between "mr-section" and "work-section"
       - Call focus_active_section()
       - Update visual indicators

    3. Implement focus_active_section():
       - Get the active section widget by ID
       - Call section.focus_table()
       - Update CSS classes for visual indication

    4. Implement watch_active_section_id() reactive watcher:
       - Called automatically when active_section_id changes
       - Update border styles: active section gets accent border, inactive gets dimmed
       - Update section titles to show active state

    5. Visual indicator approach (Claude's discretion):
       - Option A: Border color change (blue for active, gray for inactive)
       - Option B: Background tint change
       - Option C: Title styling (bold/highlight for active)
       - Use Textual's reactive CSS updating

    6. Ensure initial focus:
       - On mount, focus the first available section
       - Set active_section_id to first visible section
  </action>
  <verify>cd /Users/pg/Coding/_bucket/monocli && python -c "from monocli.ui.main_screen import MainScreen; print('has on_key:', hasattr(MainScreen, 'on_key')); print('has watch_active_section_id:', hasattr(MainScreen, 'watch_active_section_id'))"</verify>
  <done>Tab key switches between sections, active section has visual indicator, focus moves correctly</done>
</task>

<task type="auto">
  <name>Implement j/k and arrow key navigation</name>
  <files>src/monocli/ui/main_screen.py</files>
  <action>
    Add j/k and arrow key navigation within sections:

    1. Extend on_key() handler to support:
       - "j" and "down" keys: move to next item in active section
       - "k" and "up" keys: move to previous item in active section

    2. Navigation logic:
       - Get the active section widget
       - Call section.select_next() or section.select_previous()
       - Only navigate if the section has data and is focused

    3. Ensure DataTable handles these keys naturally when focused:
       - Textual's DataTable has built-in arrow key support
       - j/k can be mapped to the same actions
       - Focus must be on the DataTable for keys to work

    4. Consider adding BINDINGS to section widgets:
       - Alternative: Use DataTable's built-in bindings
       - DataTable automatically handles arrow keys when cursor visible
       - Ensure cursor_type="row" for row-level selection

    5. Handle edge cases:
       - Empty section: navigation should not crash
       - Loading section: navigation should be no-op
       - Error section: navigation should be no-op

    Implementation approach:
    - Since DataTable handles arrow keys when focused, focus management is key
    - When Tab switches sections, the new section's DataTable gets focus
    - DataTable then handles arrow keys automatically
    - Add explicit j/k handlers that delegate to DataTable navigation
  </action>
  <verify>cd /Users/pg/Coding/_bucket/monocli && python -c "from textual.widgets import DataTable; dt = DataTable(); print('cursor_type:', hasattr(dt, 'cursor_type')); print('move_cursor:', hasattr(dt, 'move_cursor'))"</verify>
  <done>j/k and arrow keys navigate items in the focused section, DataTable handles navigation naturally when focused</done>
</task>

<task type="auto">
  <name>Implement 'o' key browser integration</name>
  <files>src/monocli/ui/main_screen.py</files>
  <action>
    Add 'o' key handler to open selected item in browser:

    1. Import webbrowser module (Python standard library)

    2. Extend on_key() handler:
       - Catch "o" key press
       - Get the active section widget
       - Get selected URL: url = section.get_selected_url()
       - If url exists: webbrowser.open(url)
       - If no selection or no URL: do nothing (silent)

    3. Add error handling:
       - Wrap webbrowser.open() in try/except
       - On exception: log error and show brief notification
       - Use self.notify() for user-visible error (Textual built-in)
       - Keep it brief per user decision (no elaborate error UI)

    4. Handle edge cases:
       - No selection: silent no-op
       - Empty URL: silent no-op
       - Section loading: silent no-op
       - Section in error state: silent no-op

    5. Browser behavior:
       - Uses system's default browser
       - Opens in new tab/window per OS default
       - No confirmation per user requirement
       - No visual feedback (browser opening is feedback enough)

    6. Testing consideration:
       - webbrowser.open is hard to test in CI
       - Mock webbrowser.open in tests
       - Verify method is called with correct URL
  </action>
  <verify>cd /Users/pg/Coding/_bucket/monocli && python -c "import webbrowser; print('webbrowser available')"</verify>
  <done>Pressing 'o' opens selected item URL in default browser, handles errors gracefully</done>
</task>

<task type="auto">
  <name>Create navigation integration tests</name>
  <files>tests/ui/test_navigation.py</files>
  <action>
    Create comprehensive navigation tests:

    1. Test Tab key switches active section:
       - Initial active section is MR section
       - Press Tab → work section becomes active
       - Visual indicator updates (CSS classes)

    2. Test arrow key navigation within section:
       - Add mock data to section
       - Focus section
       - Press Down → selection moves to next row
       - Press Up → selection moves to previous row

    3. Test j/k navigation:
       - Same as arrow keys but with j/k keys
       - j moves down, k moves up

    4. Test 'o' key opens browser:
       - Mock webbrowser.open
       - Select a row
       - Press 'o'
       - Assert webbrowser.open called with correct URL

    5. Test section-scoped selection:
       - Select row in MR section
       - Switch to Work section
       - Select different row in Work section
       - Switch back to MR section
       - Assert MR section still has original selection

    6. Test edge cases:
       - 'o' with no selection does nothing
       - Navigation in empty section does nothing
       - Tab cycles between visible sections only

    Use textual.pilot.Pilot for all tests:
    - await pilot.press("tab")
    - await pilot.press("j")
    - await pilot.press("o")
    - Query widget states with pilot.app.query_one()
  </action>
  <verify>cd /Users/pg/Coding/_bucket/monocli && python -m pytest tests/ui/test_navigation.py -v</verify>
  <done>All navigation tests pass, covering Tab switching, j/k navigation, arrow keys, and browser opening</done>
</task>

</tasks>

<verification>
1. Tab key switches between sections
2. Active section has visual indicator (border/style change)
3. j/k and arrow keys navigate within active section
4. 'o' key opens selected item in browser
5. Selection persists per section (section-scoped)
6. Browser failures handled gracefully
7. All navigation tests pass
</verification>

<success_criteria>
- Tab switches active section with visual indicator
- j/k and arrow keys navigate items in focused section
- 'o' key opens selected item URL in default browser
- Selection is section-scoped (each section maintains its own selection)
- Browser open failures handled gracefully (logged, brief notification)
- No confirmation or visual feedback for browser open (browser is feedback)
- Navigation integration tests verify all keyboard interactions
</success_criteria>

<output>
After completion, create `.planning/phases/03-dashboard-ui/03-03-SUMMARY.md`
</output>
