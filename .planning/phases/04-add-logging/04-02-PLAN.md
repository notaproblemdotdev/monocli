---
phase: 04-add-logging
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/monocli/async_utils.py
  - tests/test_async_utils.py
autonomous: true
must_haves:
  truths:
    - "No more asyncio InvalidStateError exceptions in logs"
    - "Concurrent subprocess calls are properly synchronized"
    - "CLI commands execute reliably without race conditions"
  artifacts:
    - path: "src/monocli/async_utils.py"
      provides: "Fixed run_cli_command with semaphore protection"
      min_changes: "Add _subprocess_semaphore and acquire/release pattern"
    - path: "tests/test_async_utils.py"
      provides: "Tests for concurrent subprocess execution"
      min_changes: "Add test_concurrent_subprocesses_no_race_condition"
  key_links:
    - from: "run_cli_command"
      to: "asyncio.Semaphore"
      via: "_subprocess_semaphore.acquire() in try/finally"
---

<objective>
Fix asyncio InvalidStateError exceptions caused by concurrent subprocess race conditions.

Purpose: Eliminate race condition errors in logs when multiple CLI commands run simultaneously.
Output: Synchronized subprocess execution with semaphore protection.
</objective>

<execution_context>
@/Users/pg/.config/opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

## Issue Analysis

**Problem:** Logs show `asyncio.exceptions.InvalidStateError: invalid state` exceptions:
```
Exception in callback _UnixReadPipeTransport._call_connection_lost()
asyncio.exceptions.InvalidStateError: invalid state
```

**Root Cause:** Concurrent subprocess calls in `run_cli_command()` cause race conditions in asyncio's transport cleanup. When GitLab and Jira authentication checks run simultaneously, they compete for transport resources.

**Location:** src/monocli/async_utils.py, function `run_cli_command()`

**Impact:** Error spam in logs, potential instability with many concurrent operations.

## Solution

Add an `asyncio.Semaphore` to limit concurrent subprocess execution:
- Max 3 concurrent subprocesses (reasonable for CLI tools)
- Acquire semaphore before creating subprocess
- Release in finally block to ensure cleanup
- Prevents transport cleanup race conditions

## Files to Modify

- src/monocli/async_utils.py - Add semaphore protection
- tests/test_async_utils.py - Add concurrency tests
</context>

<tasks>

<task type="auto">
  <name>Add semaphore to prevent subprocess race conditions</name>
  <files>src/monocli/async_utils.py</files>
  <action>
    Update src/monocli/async_utils.py to fix the race condition:

    1. Add module-level semaphore (after imports):
       ```python
       # Semaphore to prevent race conditions in concurrent subprocess execution
       _subprocess_semaphore = asyncio.Semaphore(3)
       ```

    2. Modify run_cli_command() to use semaphore:
       ```python
       async def run_cli_command(
           cmd: list[str],
           timeout: float = 30.0,
           check: bool = True,
       ) -> str:
           """Run a CLI command asynchronously and return stdout."""
           executable = cmd[0]
           if not shutil.which(executable):
               raise CLINotFoundError(executable)

           proc: asyncio.subprocess.Process | None = None
           async with _subprocess_semaphore:  # Prevent race conditions
               try:
                   proc = await asyncio.create_subprocess_exec(
                       *cmd,
                       stdout=asyncio.subprocess.PIPE,
                       stderr=asyncio.subprocess.PIPE,
                   )
                   stdout, stderr = await asyncio.wait_for(
                       proc.communicate(), timeout=timeout
                   )
               except asyncio.TimeoutError:
                   if proc is not None and proc.returncode is None:
                       proc.kill()
                   raise asyncio.TimeoutError(
                       f"Command '{' '.join(cmd)}' timed out after {timeout}s"
                   )

           stdout_str = stdout.decode().strip()
           stderr_str = stderr.decode().strip()

           if check and proc is not None and proc.returncode is not None and proc.returncode != 0:
               raise_for_error(cmd, proc.returncode, stderr_str)

           return stdout_str
       ```

    Key changes:
    - Wrap subprocess creation in `async with _subprocess_semaphore:`
    - Move stdout/stderr variable declarations inside the async with block
    - Semaphore limits to 3 concurrent subprocesses
  </action>
  <verify>cd /Users/pg/Coding/_bucket/monocli && uv run python -c "from monocli.async_utils import run_cli_command, _subprocess_semaphore; print(f'Semaphore value: {_subprocess_semaphore._value}')"</verify>
  <done>Semaphore added and importable, run_cli_command updated with async with block</done>
</task>

<task type="auto">
  <name>Add test for concurrent subprocess execution</name>
  <files>tests/test_async_utils.py</files>
  <action>
    Create/update tests/test_async_utils.py with concurrency tests:

    1. Create the test file with:
       - Test that multiple concurrent subprocess calls complete without errors
       - Test that semaphore limits concurrent execution
       - Test that subprocess cleanup works correctly

    2. Example test structure:
       ```python
       import asyncio
       import pytest
       from monocli.async_utils import run_cli_command, _subprocess_semaphore

       @pytest.mark.asyncio
       async def test_concurrent_subprocesses_no_race_condition():
           """Test that concurrent subprocess calls don't cause race conditions."""
           # Run multiple echo commands concurrently
           tasks = [
               run_cli_command(["echo", f"test{i}"], check=False)
               for i in range(5)
           ]
           results = await asyncio.gather(*tasks, return_exceptions=True)
           
           # All should succeed without exceptions
           assert len(results) == 5
           for i, result in enumerate(results):
               assert not isinstance(result, Exception), f"Task {i} failed: {result}"
               assert result == f"test{i}"

       @pytest.mark.asyncio
       async def test_semaphore_limits_concurrent_execution():
           """Test that semaphore limits concurrent subprocesses."""
           # Initial value should be 3
           assert _subprocess_semaphore._value == 3
       ```
  </action>
  <verify>cd /Users/pg/Coding/_bucket/monocli && uv run pytest tests/test_async_utils.py -v</verify>
  <done>Concurrency tests pass without InvalidStateError exceptions</done>
</task>

<task type="auto">
  <name>Verify fix by running app and checking logs</name>
  <files>src/monocli/async_utils.py</files>
  <action>
    Verify the race condition fix:

    1. Run the application to trigger concurrent CLI operations:
       ```bash
       cd /Users/pg/Coding/_bucket/monocli && timeout 5 uv run python -m monocli --debug 2>&1 || true
       ```

    2. Check that logs don't contain InvalidStateError:
       ```bash
       if grep -q "InvalidStateError" ~/.local/share/monocli/logs/monocli_*.log 2>/dev/null; then
           echo "ERROR: Still seeing InvalidStateError in logs"
           exit 1
       else
           echo "SUCCESS: No InvalidStateError in recent logs"
       fi
       ```

    3. Verify semaphore is working by checking log structure:
       - Look for sequential "Checking authentication" messages
       - No asyncio exception stack traces
  </action>
  <verify>cd /Users/pg/Coding/_bucket/monocli && ! grep -q "InvalidStateError" ~/.local/share/monocli/logs/monocli_*.log 2>/dev/null && echo "Fix verified - no race condition errors"</verify>
  <done>No InvalidStateError exceptions in logs after fix</done>
</task>

<task type="auto">
  <name>Run full test suite to ensure no regressions</name>
  <files>tests/</files>
  <action>
    Run complete test suite to verify the fix doesn't break anything:

    1. Run all tests:
       ```bash
       uv run pytest tests/ -v
       ```

    2. Check for any test failures related to async operations

    3. Verify adapters still work correctly with semaphore
  </action>
  <verify>cd /Users/pg/Coding/_bucket/monocli && uv run pytest tests/ -v --tb=short</verify>
  <done>All tests pass without regressions</done>
</task>

</tasks>

<verification>
1. Semaphore is added to async_utils.py with value of 3
2. run_cli_command wraps subprocess in `async with _subprocess_semaphore:`
3. Concurrency tests pass without InvalidStateError
4. Application runs without asyncio exceptions in logs
5. All existing tests still pass
</verification>

<success_criteria>
- No more `asyncio.exceptions.InvalidStateError` in logs
- Concurrent subprocess calls complete successfully
- Semaphore limits execution to 3 concurrent subprocesses
- All tests pass
- Application runs stable with concurrent CLI operations
</success_criteria>

<output>
After completion, create `.planning/phases/04-add-logging/04-02-SUMMARY.md`
</output>
