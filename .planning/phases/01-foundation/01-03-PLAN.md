---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - src/monocli/async_utils.py
  - src/monocli/exceptions.py
  - tests/test_async_utils.py
autonomous: true
must_haves:
  truths:
    - Async subprocess calls complete without blocking the main thread
    - Textual Workers API used with @work(exclusive=True) decorator
    - Failed CLI calls raise CLIError with descriptive messages (exit code, stderr)
    - No silent failures - all errors propagate with context
    - Async utilities tested with pytest-asyncio
  artifacts:
    - path: src/monocli/exceptions.py
      provides: "Custom exceptions for CLI errors"
      exports: ["CLIError", "CLIAuthError", "CLINotFoundError"]
      min_lines: 30
    - path: src/monocli/async_utils.py
      provides: "Async subprocess utilities with Textual Workers integration"
      exports: ["run_cli_command", "fetch_with_worker", "CLIAdapter"]
      min_lines: 80
    - path: tests/test_async_utils.py
      provides: "Async tests for subprocess utilities"
      min_lines: 100
  key_links:
    - from: src/monocli/async_utils.py
      to: src/monocli/exceptions.py
      via: "import CLIError"
      pattern: "from monocli.exceptions import"
    - from: src/monocli/async_utils.py
      to: src/monocli/models.py
      via: "parse output into models"
      pattern: "from monocli.models import"
    - from: tests/test_async_utils.py
      to: src/monocli/async_utils.py
      via: "import and test"
      pattern: "from monocli.async_utils import"
---

<objective>
Implement async subprocess utilities using asyncio.create_subprocess_exec and Textual Workers API with @work(exclusive=True). Create custom exception hierarchy for CLI errors with descriptive messages.

Purpose: Enable non-blocking data fetching from platform CLIs with proper error handling and race condition prevention.
Output: Robust async utilities that integrate with Textual's Worker system and provide clear error reporting.
</objective>

<execution_context>
@/Users/pg/.config/opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md (ASYNC-01, ASYNC-02, ASYNC-03, ASYNC-04)

## Requirements Covered
- ASYNC-01: Data fetching uses Textual Workers API with @work decorator
- ASYNC-02: Workers use exclusive=True to prevent race conditions
- ASYNC-03: UI remains responsive during data fetching (non-blocking)
- ASYNC-04: Failed CLI calls handled gracefully with error messages

## Technical Context

### Textual Workers API Pattern
```python
from textual.worker import Worker, get_current_worker
from textual.reactive import reactive

class DataFetcher(Widget):
    data = reactive(list)
    
    @work(exclusive=True)  # Prevents race conditions
    async def fetch_data(self) -> None:
        result = await run_cli_command(["glab", "mr", "list", "--json"])
        self.data = result
```

### Async Subprocess Pattern
```python
async def run_cli_command(cmd: list[str]) -> str:
    proc = await asyncio.create_subprocess_exec(
        *cmd,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE,
    )
    stdout, stderr = await proc.communicate()
    if proc.returncode != 0:
        raise CLIError(cmd, proc.returncode, stderr.decode())
    return stdout.decode()
```

### Error Handling Requirements
- CLI not installed → CLINotFoundError (check before running)
- Exit code non-zero → CLIError with exit code and stderr
- Auth failure → CLIAuthError (detect from stderr patterns)
- Timeout → asyncio.TimeoutError wrapper
</context>

<tasks>

<task type="auto">
  <name>Create custom exception hierarchy</name>
  <files>src/monocli/exceptions.py</files>
  <action>
Create src/monocli/exceptions.py with custom exceptions:

```python
"""Custom exceptions for monocli CLI operations."""


class CLIError(Exception):
    """Base exception for CLI command failures."""
    
    def __init__(self, command: list[str], returncode: int, stderr: str) -> None:
        self.command = command
        self.returncode = returncode
        self.stderr = stderr
        cmd_str = " ".join(command)
        super().__init__(
            f"Command '{cmd_str}' failed with exit code {returncode}: {stderr[:200]}"
        )


class CLIAuthError(CLIError):
    """Raised when CLI command fails due to authentication issues."""
    
    AUTH_PATTERNS = ["authentication failed", "unauthorized", "401", "not logged in"]
    
    def __init__(self, command: list[str], returncode: int, stderr: str) -> None:
        super().__init__(command, returncode, stderr)
        self.message = "Authentication failed. Please run the CLI's login command."


class CLINotFoundError(CLIError):
    """Raised when the CLI executable is not found."""
    
    def __init__(self, cli_name: str) -> None:
        self.cli_name = cli_name
        super().__init__(
            command=[cli_name],
            returncode=127,
            stderr=f"{cli_name}: command not found"
        )


def raise_for_error(command: list[str], returncode: int, stderr: str) -> None:
    """Raise appropriate exception based on error type."""
    stderr_lower = stderr.lower()
    if any(pattern in stderr_lower for pattern in CLIAuthError.AUTH_PATTERNS):
        raise CLIAuthError(command, returncode, stderr)
    raise CLIError(command, returncode, stderr)
```

Add module docstring and type hints throughout.
  </action>
  <verify>
    - `uv run python -c "from monocli.exceptions import CLIError, CLIAuthError, CLINotFoundError; print('OK')"`
    - Exception instantiation works: `CLIError(["gh"], 1, "error")`
    - Error message formatting includes command and exit code
  </verify>
  <done>
    Custom exception hierarchy with CLIError base, auth error detection, and not-found error
  </done>
</task>

<task type="auto">
  <name>Implement async subprocess utilities</name>
  <files>src/monocli/async_utils.py</files>
  <action>
Create src/monocli/async_utils.py with async utilities:

```python
"""Async subprocess utilities for CLI operations with Textual Workers integration."""
import asyncio
import shutil
from typing import Any

from textual.worker import Worker, get_current_worker

from monocli.exceptions import CLIError, CLINotFoundError, raise_for_error


async def run_cli_command(
    cmd: list[str],
    timeout: float = 30.0,
    check: bool = True,
) -> str:
    """Run a CLI command asynchronously and return stdout.
    
    Args:
        cmd: Command and arguments as list
        timeout: Timeout in seconds
        check: If True, raise CLIError on non-zero exit
        
    Returns:
        Command stdout as string
        
    Raises:
        CLINotFoundError: If executable not found
        CLIError: If command fails and check=True
        asyncio.TimeoutError: If command times out
    """
    executable = cmd[0]
    if not shutil.which(executable):
        raise CLINotFoundError(executable)
    
    try:
        proc = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        stdout, stderr = await asyncio.wait_for(
            proc.communicate(),
            timeout=timeout
        )
    except asyncio.TimeoutError:
        if proc.returncode is None:
            proc.kill()
        raise asyncio.TimeoutError(f"Command '{' '.join(cmd)}' timed out after {timeout}s")
    
    stdout_str = stdout.decode().strip()
    stderr_str = stderr.decode().strip()
    
    if check and proc.returncode != 0:
        raise_for_error(cmd, proc.returncode, stderr_str)
    
    return stdout_str


def fetch_with_worker(
    widget: Any,
    fetch_func: callable,
    *args,
    **kwargs
) -> Worker:
    """Start a Textual Worker for fetching data with exclusive=True.
    
    Args:
        widget: Textual widget to bind worker to
        fetch_func: Async function to run
        *args, **kwargs: Arguments for fetch_func
        
    Returns:
        Worker instance
    """
    from textual.worker import Worker
    
    async def _exclusive_fetch() -> Any:
        return await fetch_func(*args, **kwargs)
    
    return widget.run_worker(
        _exclusive_fetch,
        exclusive=True,  # Prevents race conditions
        thread=True,  # Run in thread for CPU-bound parsing
    )


class CLIAdapter:
    """Base class for CLI adapters with common utilities."""
    
    def __init__(self, cli_name: str) -> None:
        self.cli_name = cli_name
        self._available: bool | None = None
    
    def is_available(self) -> bool:
        """Check if the CLI is installed."""
        if self._available is None:
            self._available = shutil.which(self.cli_name) is not None
        return self._available
    
    async def run(self, args: list[str], **kwargs) -> str:
        """Run CLI with given arguments."""
        return await run_cli_command([self.cli_name] + args, **kwargs)
```
  </action>
  <verify>
    - `uv run python -c "from monocli.async_utils import run_cli_command, fetch_with_worker, CLIAdapter; print('OK')"`
    - CLIAdapter.is_available() works for existing commands (test with 'python' or 'echo')
    - run_cli_command(['echo', 'hello']) returns 'hello'
    - CLINotFoundError raised for non-existent command
  </verify>
  <done>
    Async subprocess utilities with timeout, error handling, and Textual Worker integration
  </done>
</task>

<task type="auto">
  <name>Add model parsing integration to CLIAdapter</name>
  <files>src/monocli/async_utils.py</files>
  <action>
Extend CLIAdapter in async_utils.py to include model parsing methods:

```python
import json
from typing import TypeVar, Type
from pydantic import BaseModel

from monocli.models import MergeRequest, JiraWorkItem

T = TypeVar("T", bound=BaseModel)

class CLIAdapter:
    """Base class for CLI adapters with common utilities."""
    
    def __init__(self, cli_name: str) -> None:
        self.cli_name = cli_name
        self._available: bool | None = None
    
    def is_available(self) -> bool:
        """Check if the CLI is installed."""
        if self._available is None:
            self._available = shutil.which(self.cli_name) is not None
        return self._available
    
    async def run(self, args: list[str], **kwargs) -> str:
        """Run CLI with given arguments."""
        return await run_cli_command([self.cli_name] + args, **kwargs)
    
    async def fetch_json(self, args: list[str], **kwargs) -> list[dict]:
        """Run CLI command and parse JSON output.
        
        Args:
            args: CLI arguments
            **kwargs: Additional arguments for run_cli_command
            
        Returns:
            Parsed JSON as list of dicts
        """
        output = await self.run(args, **kwargs)
        if not output.strip():
            return []
        return json.loads(output)
    
    async def fetch_and_parse(
        self, 
        args: list[str], 
        model_class: Type[T], 
        **kwargs
    ) -> list[T]:
        """Run CLI command, parse JSON, and validate into Pydantic models.
        
        Args:
            args: CLI arguments
            model_class: Pydantic model class to parse items into
            **kwargs: Additional arguments for run_cli_command
            
        Returns:
            List of validated Pydantic model instances
        """
        data = await self.fetch_json(args, **kwargs)
        if not isinstance(data, list):
            data = [data]
        return [model_class.model_validate(item) for item in data]
```

This integrates with Pydantic models from 01-02, satisfying DATA-03 requirement that "All CLI responses parsed and validated with Pydantic models."
  </action>
  <verify>
    - `uv run python -c "from monocli.async_utils import CLIAdapter; print('fetch_and_parse available')"`
    - CLIAdapter.fetch_json method exists and works with echo '[{"test": 1}]'
    - CLIAdapter.fetch_and_parse method signature accepts model_class parameter
  </verify>
  <done>
    CLIAdapter has fetch_json() for raw JSON and fetch_and_parse() for Pydantic model validation
  </done>
</task>

<task type="auto">
  <name>Create async utility tests including model parsing</name>
  <files>tests/test_async_utils.py</files>
  <action>
Create tests/test_async_utils.py with async tests:

```python
"""Tests for async subprocess utilities."""
import asyncio
import pytest

from monocli.async_utils import run_cli_command, CLIAdapter
from monocli.exceptions import CLIError, CLINotFoundError


class TestRunCliCommand:
    """Tests for run_cli_command function."""
    
    @pytest.mark.asyncio
    async def test_run_simple_command(self):
        """Test running a simple echo command."""
        result = await run_cli_command(["echo", "hello"])
        assert result == "hello"
    
    @pytest.mark.asyncio
    async def test_run_with_multiple_args(self):
        """Test command with multiple arguments."""
        result = await run_cli_command(["echo", "hello", "world"])
        assert result == "hello world"
    
    @pytest.mark.asyncio
    async def test_run_invalid_command_raises_not_found(self):
        """Test that non-existent command raises CLINotFoundError."""
        with pytest.raises(CLINotFoundError) as exc_info:
            await run_cli_command(["definitely_not_a_real_command_12345"])
        assert "definitely_not_a_real_command_12345" in str(exc_info.value)
    
    @pytest.mark.asyncio
    async def test_run_failing_command_raises_error(self):
        """Test that failing command raises CLIError."""
        with pytest.raises(CLIError) as exc_info:
            await run_cli_command(["python", "-c", "import sys; sys.exit(1)"])
        assert exc_info.value.returncode == 1
    
    @pytest.mark.asyncio
    async def test_run_without_check_does_not_raise(self):
        """Test that check=False prevents exception on failure."""
        result = await run_cli_command(
            ["python", "-c", "import sys; sys.exit(1)"],
            check=False
        )
        # Should not raise, but result might be empty
        assert isinstance(result, str)
    
    @pytest.mark.asyncio
    async def test_run_with_timeout(self):
        """Test that timeout parameter works."""
        # This should complete quickly
        result = await run_cli_command(["echo", "hi"], timeout=5.0)
        assert result == "hi"
    
    @pytest.mark.asyncio
    async def test_run_timeout_raises(self):
        """Test that slow command raises TimeoutError."""
        with pytest.raises(asyncio.TimeoutError):
            await run_cli_command(
                ["python", "-c", "import time; time.sleep(10)"],
                timeout=0.1
            )


class TestCLIAdapter:
    """Tests for CLIAdapter class."""
    
    def test_adapter_creation(self):
        """Test creating a CLI adapter."""
        adapter = CLIAdapter("echo")
        assert adapter.cli_name == "echo"
    
    def test_is_available_true(self):
        """Test that available CLI returns True."""
        adapter = CLIAdapter("echo")
        assert adapter.is_available() is True
    
    def test_is_available_false(self):
        """Test that missing CLI returns False."""
        adapter = CLIAdapter("definitely_missing_12345")
        assert adapter.is_available() is False
    
    def test_is_available_caches_result(self):
        """Test that availability is cached."""
        adapter = CLIAdapter("echo")
        first = adapter.is_available()
        second = adapter.is_available()
        assert first == second
        assert adapter._available is not None
    
    @pytest.mark.asyncio
    async def test_adapter_run(self):
        """Test running command through adapter."""
        adapter = CLIAdapter("echo")
        result = await adapter.run(["hello"])
        assert result == "hello"
    
    @pytest.mark.asyncio
    async def test_adapter_run_not_available(self):
        """Test that unavailable adapter raises."""
        adapter = CLIAdapter("definitely_missing_12345")
        with pytest.raises(CLINotFoundError):
            await adapter.run(["arg"])


class TestErrorMessages:
    """Tests for error message quality."""
    
    @pytest.mark.asyncio
    async def test_error_includes_command(self):
        """Test that error includes the command that failed."""
        with pytest.raises(CLIError) as exc_info:
            await run_cli_command(["python", "-c", "sys.exit(1)"])
        error_str = str(exc_info.value)
        assert "python" in error_str
        assert "exit code 1" in error_str
    
    @pytest.mark.asyncio
    async def test_error_includes_stderr(self):
        """Test that error includes stderr content."""
        with pytest.raises(CLIError) as exc_info:
            await run_cli_command([
                "python", "-c", 
                "import sys; print('error message', file=sys.stderr); sys.exit(1)"
            ])
        assert "error message" in str(exc_info.value)


class TestModelParsingIntegration:
    """Tests for CLIAdapter model parsing with Pydantic."""
    
    @pytest.mark.asyncio
    async def test_fetch_json_parses_echo_output(self):
        """Test that fetch_json parses echo JSON output."""
        adapter = CLIAdapter("echo")
        result = await adapter.fetch_json(['{"test": 1}'])
        assert result == [{"test": 1}]
    
    @pytest.mark.asyncio
    async def test_fetch_json_empty_output_returns_empty_list(self):
        """Test that empty output returns empty list."""
        adapter = CLIAdapter("echo")
        result = await adapter.fetch_json([""])
        assert result == []
    
    @pytest.mark.asyncio  
    async def test_fetch_and_parse_with_pydantic_model(self):
        """Test that fetch_and_parse validates into Pydantic models."""
        from pydantic import BaseModel
        
        class TestItem(BaseModel):
            id: int
            name: str
        
        adapter = CLIAdapter("echo")
        # echo '[{"id": 1, "name": "test"}]' | parse
        result = await adapter.fetch_and_parse(
            ['[{"id": 1, "name": "test"}]'],
            TestItem
        )
        assert len(result) == 1
        assert isinstance(result[0], TestItem)
        assert result[0].id == 1
        assert result[0].name == "test"
    
    @pytest.mark.asyncio
    async def test_fetch_and_parse_invalid_data_raises_validation_error(self):
        """Test that invalid data raises Pydantic validation error."""
        from pydantic import BaseModel, ValidationError
        
        class TestItem(BaseModel):
            id: int
            name: str
        
        adapter = CLIAdapter("echo")
        # Missing 'name' field should raise ValidationError
        with pytest.raises(ValidationError):
            await adapter.fetch_and_parse(
                ['[{"id": 1}]'],
                TestItem
            )
```

Run tests: `uv run pytest tests/test_async_utils.py -v`
  </action>
  <verify>
    - `uv run pytest tests/test_async_utils.py -v` passes all tests
    - Coverage includes: success cases, failure cases, timeout, not found, adapter
    - `uv run mypy src/monocli/async_utils.py` passes type checking
  </verify>
  <done>
    Async utilities tested with pytest-asyncio, all error cases covered
  </done>
</task>

</tasks>

<verification>
- [ ] `uv run python -c "from monocli.async_utils import run_cli_command, CLIAdapter"` works
- [ ] `echo` command test: `uv run python -c "import asyncio; from monocli.async_utils import run_cli_command; print(asyncio.run(run_cli_command(['echo', 'hello'])))"`
- [ ] Non-existent command raises CLINotFoundError
- [ ] Failing command raises CLIError with exit code and stderr
- [ ] `uv run pytest tests/test_async_utils.py` passes (all async tests)
- [ ] `@work(exclusive=True)` pattern documented in code
</verification>

<success_criteria>
1. Async subprocess calls complete without blocking (asyncio.create_subprocess_exec)
2. Textual Workers API integration with @work(exclusive=True) decorator
3. Custom exception hierarchy: CLIError, CLIAuthError, CLINotFoundError
4. Failed CLI calls raise exceptions with descriptive messages (no silent failures)
5. All async utilities tested with pytest-asyncio
6. Type checking passes with mypy
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
